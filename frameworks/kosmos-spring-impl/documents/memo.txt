◆DI
	○EJB
		CDIを使用するとWEBからEJBまで一つのＤＩの仕組みで提供可能
		@Alternativeを使用しておけばbeans.xmlで複数beanのうちどちらを使用するか選択することができる。SpringのAutowiredよりは柔軟。
		生成されたBeanのフィールドに対するInjectionはアノテーションを用いてのみ可能であり、beans.xmlには記載できない。
		他、同じインターフェースで2種類のbeanをいい感じで同居させられない。アプリはこれでよいが、フレームワークの場合は困る。
		まあ、クラスいっぱい作ればいできるけど、xmlにいろいろかけないと結合テストと単体テストとか同じシステムなのに環境わけたいときにxmlの差し替えだけですまないのがだるい。


◆単体テストはSpring有利（圧倒的）	
	○EJB
	まともな単体テストツールがない。glassfishのEJBContainer.create()は動作が怪しい。
		・起動が遅い	
		・java:global指定のJNDIしか使用できない。java:/module指定は不可能。
		・test-classesにセッションBeanをコピーして読み込み対象ディレクトリを指定する必要がある。
		・他のjarファイルの中身まで読み込んでくれないのでフレームワーク等を読み込ませるのが不可能と思われる。
	実際にEJBコンテナを起動してテストするには重過ぎる上にカバレッジ取得不可能
	大規模で簡単にテストするにはEJBコンテナの実装を作リ込む必要がある。
	
	○Spring
	起動が早い。
	トランザクション管理をきちんと行いたい場合は-javaagentをvmオプションにつけておけばよい。
		・テストクラス毎に設定するのは馬鹿らしいので、プロジェクトが使用しているJDKのvmオプションに指定する。
		・これを指定しないと独自で取得したコネクションとJPAセッションのコネクションが不整合になり結果がおかしくなり、DBUnit使用時などは初期データが反映されないなど起こりうる。
	JMS-Producer、RequiresNewスコープなどのテストも可能、インターセプターも呼び出し可能。ただしJMS-Producerを成功させるにはMQを立ち上げておく必要がある。
	
◆移植性
	○EJB
	EJBコンテナがないと動作しない。Tomcat/Jettyでは動作させることはできない。CDI動かせばなんとかなるか。
	glassfish v3だとejb-jar.xmlに記載しただけでは認識しない。@SessionBeanが必ず必要のようだ。

	○Spring
	Spring自身がコンテナであるためどこでも動作する。JavaEEコンテナである必要はない。
	ただし、ＪＴＡ使う場合は注意が必要。TomcatだとJTAサポートしてないのでどっかからJTAの実装持ってくる必要がある。
	
◆トランザクション管理
	○EJB
	JTA使用可能。
	SessionContextにrollbackフラグがあり、EJBコンテナが発生したExceptionの種類に従ってこのフラグを設定する。
	setRollbackOnlyをたたくことでアプリから制御することも可能。トランザクション境界の判定方法がEJBコンテナの実装に依存する。
	getRollbackOnlyがtrueだと以降でSessionBeanの生成ができない。基本的に即時終了しかない。
	
	○Spring
	JTA使用可能。
	Springのトランザクション管理はインターセプターで実施している。トランザクション境界でコミット、ロールバックを実行しているが、
	このインターセプターを自前で用意したり拡張することが可能。従ってかなり柔軟に手をいれらる。例えば、
	あるトランザクションの中でエラーメッセージが追加されていたらインターセプターでrollbackフラグを立てたり（EJBと同じように）、Exceptionの発生を制御できるなど可能。	
	デフォルトではrollbackフラグの概念はなくExceptionの発生有無でトランザクションをどうするかコンテナが決定する。
	トランザクションがロールバック状態になってもBeanの生成は可能。
	
◆DI
	○EJB
	リソースインジェクション。@EJB、@Resourceなど複数使用が前提。CDI（JSR 299）を利用することによりSpringのような汎用DIと同様にレイヤを意識する必要がなくなる。
	JNDIがベース。xmlファイルでも登録可能。
	prototypeスコープがない。lookupする場合、Beanの名称がjava/global/applicationなど複数規約で規定されている。
	
	○Spring
	汎用インジェクション。WEB～インテグレーションまで同一のDI方法。どのクラスでもサービス登録さえすれば同じように利用可能。
	Spring独自管理。JNDIの利用も可能。xmlファイルでも登録可能。	
	スコープはprototypeとsingleton。	spring-webを使用することでリクエスト、セッション、アプリケーションのスコープ指定が可能になる。
	ライフサイクルは上記の通り。イベントはpostConstructとpreDestroyのみ。
	提供スコープを拡張できる。ページやConversationの実現も可能。
	DIに対する振る舞いを拡張できる。（自分でDI用のアノテーションを作成できるなど）
	lookupする場合Beanの名称は任意に指定可能。（アノテーションドリブンで使用している名称と同じ）

◆メッセージング
○全体
・JTAにしないとコネクションクローズ時にコミットされるのでJTA環境前提。
・jndiでコネクションファクトリをアプリに読み込む、接続先や再接続設定はミドルウェア側でコネクションファクトリごとに設定しておく。	
・glassfishの場合は管理コンソールからConnection Factoiesの設定でAdditional PropertiesにaddressListプロパティを追加して
接続先のMQアドレスをカンマ区切りで指定することで定したアドレスたちに振り分ける。デフォルトでは振分けアルゴリズムはランダムになっているが指定して順番に振分ける方法もある。
http://download.oracle.com/docs/cd/E19528-01/820-0846/gbnnp/index.html

○Spring
ローカルのMQにつなぐとMessageListenerが警告をあげる。なぜだ。
メッセージリスナーはポーリングでキューからgetしてる。コンシューマ側の負荷は少なくできるがレイテンシがあるので同期のリモートコールで使うのはNG。
MessageListerを複数同じキューに対して設定できるが、必ず空いているリスナーが使用されるわけではないらしい。
キューが埋まっている時にさらにキューに追加して空き待ちになった後、先行している処理が終了しスレッドが空いても処理されないことがある。
どうやら全てのスレッドがうまっていても適当なスレッドに既にリクエストが割り当てられているためと思われる。
スレッド増やしたり他サーバのMQにListener接続しにいけるのでコンシューマいっぱいならべればちゃんとさばけるかも。
自動でDMQに移動しないので最悪。
MDB起動してからSpring呼び出すのも無理。MDBですでにトランザクションが開始しているためSpringのトランザクションを開始するとエラーになる。

								MessageListener(polling)
										↓
	MessageListener(polling)	→	|OpenMQ(HA)|	←	MessageListener(polling)
										↑
								MessageListener(polling)

・Springはテスト時にJUnitで動作させたり、軽量なTomcatで起動させて動作確認するなどが可能。EJBだと起動に時間かかってテストも容易ではない。
・業務要件からくる機能拡張など手の入れやすさが楽。Springコンテナ自身にDIさせてこちらで作成したクラスを提供することが可能。
・テスト時の工数と手の入れやすさでSpringの優位性があると思われるが非同期はNG。	
